# -*- coding: utf-8 -*-
"""
Created on Fri Dec 27 14:54:59 2018

@author: dujingb
"""

import pickle
import numpy as np
import pandas as pd
from keras.models import load_model
from keras.preprocessing import sequence
from keras.layers import Average
from datetime import datetime

def ensemble_predict(test_path, tokenizer_path, result_path):
    # Loading processed word dictionary into keras Tokenizer would be better
    max_length = 1024
    print('load data...')
    tokenizer = pickle.load(open(tokenizer_path, 'rb'))
    text = pd.read_csv(test_path)['api'].values
    file_id = pd.read_csv(test_path)['file_id']
    print('transfer texts to sequences...then pad each sequence...')
    X = tokenizer.texts_to_sequences(text)
    X = sequence.pad_sequences(X, maxlen=max_length)
    print('load model...')
    lstm_model = load_model('mini_model/lstm_model.h5')
    lstm_model.load_weights('mini_model/best-lstm_weights.h5')
    #cnn_model = load_model('')
    #cnn_model.load_weights('')
    cnn_lstm_model = load_model('mini_model/cnn_lstm_model.h5')
    cnn_lstm_model.load_weights('mini_model/best-cnn_lstm_weights.h5')
    
    models = [lstm_model, cnn_lstm_model]
    outputs = []
    for model in models:
        pred = model.predict_proba(X, verbose = 1, batch_size = 32)
        outputs.append(pred)
    prediction = (outputs[0] + outputs[1])/2
    #outputs1= [model.outputs[0] for model in models]
    #prediction1 = Average()(outputs1)
    #print(prediction1)  #prediction1是一个tensor
    #prediction = np.around(prediction, decimals = 7) #保留七位小数
    df = pd.DataFrame(columns = ['prob0','prob1','prob2','prob3','prob4','prob5','prob6','prob7'], data = prediction)
    df = df.round(7) # 保留七位小数
    df.insert(0, 'file_id', file_id)
    df.to_csv(result_path, index = None)  
    print('save probability of each label finished!')
	
if __name__ == '__main__':
    test_path = 'mini_data/test_set.csv'
    tokenizer_path = 'mini_build/tokenizer.pkl'
    dt = datetime.now() 
    d = dt.date()
    h = dt.time().hour
    m = dt.time().minute
    time_str = '{}_{}{}'.format(d, h, m)
    result_path = 'mini_data/ensemble_result_{}.csv'.format(time_str)
    ensemble_predict(test_path, tokenizer_path, result_path)
    
    


